---
name: Snake & Movement Logic
status: completed
created: 2025-11-15T16:20:35Z
updated: 2025-11-15T17:05:00Z
completed: 2025-11-15T17:05:00Z
github: https://github.com/imezh/snake-game/issues/4
depends_on: [3]
parallel: false
conflicts_with: []
---

# Task: Snake & Movement Logic

## Description
Implement the snake entity with its data structure, movement logic, and growth mechanics. Create the input handler to process arrow key controls with direction queuing and reverse prevention. Snake should move continuously in a grid-based pattern and respond accurately to player input.

## Acceptance Criteria
- [x] Snake data structure stores segments as {x, y} coordinates
- [x] Snake initializes at center of grid with length of 3 segments
- [x] Snake moves continuously in current direction at fixed intervals
- [x] Arrow key input changes snake direction correctly
- [x] Direction reversals are prevented (can't go left when moving right)
- [x] Input queue prevents multiple direction changes per game tick
- [x] Snake growth logic adds new segment when triggered
- [x] Head position calculated correctly based on direction
- [x] Tail removal works properly (except when growing)
- [x] Movement is smooth and grid-aligned

## Technical Details

**Snake Data Structure:**
```javascript
const snake = {
  segments: [
    {x: 10, y: 10}, // head
    {x: 9, y: 10},  // body
    {x: 8, y: 10}   // tail
  ],
  direction: {x: 1, y: 0}, // moving right
  nextDirection: {x: 1, y: 0},
  growing: false
};

const GRID_SIZE = 20; // 20x20 grid
const CELL_SIZE = 25; // pixels
```

**Movement Algorithm:**
```javascript
function moveSnake() {
  // Update direction from queue
  snake.direction = snake.nextDirection;

  // Calculate new head position
  const head = snake.segments[0];
  const newHead = {
    x: head.x + snake.direction.x,
    y: head.y + snake.direction.y
  };

  // Add new head
  snake.segments.unshift(newHead);

  // Remove tail (unless growing)
  if (!snake.growing) {
    snake.segments.pop();
  } else {
    snake.growing = false;
  }
}
```

**Input Handler:**
```javascript
const inputQueue = [];

function handleKeyPress(event) {
  const key = event.key;

  // Prevent default browser scrolling
  if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(key)) {
    event.preventDefault();
  }

  let newDirection = null;

  switch (key) {
    case 'ArrowUp':
      newDirection = {x: 0, y: -1};
      break;
    case 'ArrowDown':
      newDirection = {x: 0, y: 1};
      break;
    case 'ArrowLeft':
      newDirection = {x: -1, y: 0};
      break;
    case 'ArrowRight':
      newDirection = {x: 1, y: 0};
      break;
  }

  if (newDirection && isValidDirection(newDirection)) {
    queueDirection(newDirection);
  }
}

function isValidDirection(direction) {
  // Prevent reversing direction
  const currentDir = snake.direction;
  return !(direction.x === -currentDir.x && direction.y === -currentDir.y);
}

function queueDirection(direction) {
  // Only queue if not already queued and queue isn't full
  if (inputQueue.length < 2) {
    inputQueue.push(direction);
  }
}

function processInputQueue() {
  if (inputQueue.length > 0) {
    snake.nextDirection = inputQueue.shift();
  }
}
```

**Growth Logic:**
```javascript
function growSnake() {
  snake.growing = true;
  // Next move will not remove tail
}
```

**Code Locations:**
- `game.js`: Snake object, movement functions, input handler

**Key Considerations:**
- Input queue allows buffering one direction change between updates
- Direction validation prevents instant death from reverse moves
- Growing flag is one-time use per food consumption
- Grid coordinates are 0-based indices
- Movement happens at game tick rate, not frame rate

## Dependencies
- [x] Task 002 completed (game loop and state management)

## Effort Estimate
- **Size:** M
- **Hours:** 14-16 hours
- **Parallel:** false (core gameplay mechanic)

## Definition of Done
- [x] Snake data structure implemented correctly
- [x] Snake spawns at center with 3 segments facing right
- [x] Continuous movement works at correct speed
- [x] All four arrow keys control direction properly
- [x] Cannot reverse direction (validated and tested)
- [x] Input queue prevents double-input glitches
- [x] Growth logic adds exactly one segment
- [x] Movement is smooth and grid-aligned
- [x] No stuttering or irregular movement
- [x] Edge cases tested (rapid key presses, boundary moves)
- [x] Code is well-commented
- [x] Keyboard event listeners properly attached/detached
